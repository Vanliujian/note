- 今日任务：把上次的ThreadPoolExecutor剩余的几个方法学完，理解rpc在架构的位置，用于解决什么问题

### runWorker方法

执行任务流程，进行中断线程相关的lock操作

通过t.start()--->run()--->runWorker()

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    //设置允许中断，unlock会调用release(1),release会调用tryRelease，这个调用的是Worker对象的tryRelease
    //将worker的state归位为0，代表可以被中断
    w.unlock();
    //标识（标识勾子函数是否出现异常）
    boolean completedAbruptly = true;
    
    try {
        //获取任务的第一种方式是通过execute、submit传入
        //获取任务的第二种方式是通过getTask方法传入（为了解决上文说的addWorker(null,false)）
        while (task != null || (task = getTask()) != null) {
            //Worker内部实现的锁，不是可重用锁
            //因为在中断时也需要对worker进行lock，如果中断不能获取锁，代表当前工作线程正在执行
            w.lock();
            //之前说过SHUTDOWN状态并不会中断正在执行的任务，STOP会中断正在执行的任务
            //判断当前状态来确定是否中断
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 //查询中断标记位的状态并归位为false。并且当前至少要是STOP状态才可以中断
                 //为什么还要判断状态？因为可能会有并发操作
                 (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) &&
                //查询当前线程中断标记位是否是false，如果是false就执行wt.interrupt();
                //因为&&只有前面为true才会执行后面部分，前面为true代表需要中断，那么这里就进行是否中断过判断
                !wt.isInterrupted())
                //将中断标记位设置为true
                wt.interrupt();
            try {
                //勾子函数，前置增强，空实现（需要自己实现线程池时实现）
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //勾子函数，后置增强，空实现（需要自己实现线程池时实现）
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                //执行成功的任务数+1
                w.completedTasks++;
                //将state标记位置为0
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

### getTask方法

```java
private Runnable getTask() {
    
    =========================判断当前线程状态============================
    //非核心线程可以干掉
    boolean timedOut = false;

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
		//如果是>=stop需要移除当前工作线程
        //如果是shutdown且工作队列为空，需要移除当前工作线程
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            //返回null，交给processWorkerExit移除当前工作线程
            return null;
        }
	=========================判断工作线程数量============================
        int wc = workerCountOf(c);
		//allowCoreThreadTimeOut是否允许核心线程超时（一般都是false）
        //当前工作线程数是否大于核心线程数
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        //工作线程是否大于最大线程（健壮性判断）
        //在allowCoreThreadTimeOut为false情况下，只有当前线程已经超时才会进行下面判断
        if ((wc > maximumPoolSize || (timed && timedOut))
            //工作线程数大于1（如果等于1就不行，干掉后就没有工作线程来执行工作队列中的任务）
            //工作队列为空
            //满足上面两个其一就可以干掉当前工作线程
            && (wc > 1 || workQueue.isEmpty())) {
            //基于cas的方式移除当前线程，可能出现并发操作，但是cas只会移除一个，另外一个continue重新执行
            if (compareAndDecrementWorkerCount(c))
                //返回null，交给processWorkerExit移除当前工作线程
                return null;
            continue;
        }
	=========================从工作队列获取任务============================
        try {
            //timed = allowCoreThreadTimeOut || wc > corePoolSize;
            Runnable r = timed ?
                //阻塞一定时间从工作队列拿任务（简单理解为如果是非核心线程走这个方法）
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            	//一直阻塞（简单理解为如果是核心线程走这个take）
                workQueue.take();
            if (r != null)
                //如果拿到任务直接返回执行
                return r;
            //从队列获取任务时超时了
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

### processWorkerExit方法

```java
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    //什么时候completedAbruptly为true，调用processWorkerExit前，runWorker中的while循环出异常了就为true（一般是勾子函数出异常）
    if (completedAbruptly)
        //执行方式不合法，手动减扣工作线程数
        decrementWorkerCount();

    //加锁
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        //记录当前线程池一共处理了多少任务
        completedTaskCount += w.completedTasks;
        //移除工作线程
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    //尝试将线程池关闭
    tryTerminate();

    int c = ctl.get();
    //如果当前状态为RUNNING、SHUTDOWN就进入
    if (runStateLessThan(c, STOP)) {
        //如果是正常移除就进入if
        if (!completedAbruptly) {
            //allowCoreThreadTimeOut：
            	//如果为false，核心线程即使在空闲时间也保持活动状态
            	//如果为true，核心线程使用keepalivetime超时等待
            //核心线程数最小值
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            //如果min为0，且工作队列不为空，设置工作线程最小值为1
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            //如果工作线程数>=核心线程数最小值，正常返回
            if (workerCountOf(c) >= min)
                return;
        }
        //如果是非正常移除，就重新添加一个非核心工作线程
        //线程池工作队列不为空，且没有工作线程，再添加一个工作线程
        addWorker(null, false);
    }
}
```



RPC是建立在Socket之上的，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC(本地过程调用)。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。**对于RPC架构来说，应用越底层，代码越复杂、灵活性越高、效率越高；应用越上层，抽象封装的越好、代码越简单、效率越差。**

> 小结

完成线程池剩余源码的学习，对于rpc再简单的学习一下，rpc用于解决远程调用的问题。时间问题rpc暂时没有学完，回去再看