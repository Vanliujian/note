# 监控

> 悲观锁

- 很悲观，认为i什么时候都会出现问题，无论做什么都会加锁

> 乐观锁

- 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据，可以查看version
- 获取version
- 更新的时候比较一下version

> Redis 的监视测试watch

- 正常执行成功！

```bash
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> set out 0
OK
127.0.0.1:6379> watch money  # 在监视过程中数据没有被修改，那么这个事务就会执行成功
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 20
QUEUED
127.0.0.1:6379> incrby out 20
QUEUED
127.0.0.1:6379> exec
1) (integer) 80
2) (integer) 20
```



- 执行失败！

```bash
######################################
# 先打开一个客户端，称作客户端1
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> watch money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 10
QUEUED
127.0.0.1:6379> set k6 v6
QUEUED                          
                         # 在执行exec前，我们打开另一个客户端，修改money
					     # 127.0.0.1:6379> get money
                         # "100"
                         # 127.0.0.1:6379> set money 99
                         # OK
127.0.0.1:6379> exec  # 在其它地方修改监视对象过后，回来执行事务，发现执行未成功。若未成功，则客户端1的事务就等同于都未执行
(nil)
127.0.0.1:6379> get money
"99"
```

使用watch监视来充当乐观锁

如果要解锁就用 unwatch

不过一个事务执行结束后，都会自动解锁。



